<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>一、【Java并发】初识线程</title>
      <link href="/thread_one/"/>
      <url>/thread_one/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程介绍"><a href="#1-线程介绍" class="headerlink" title="1. 线程介绍"></a>1. 线程介绍</h2><p>对于计算机来说每一个任务就是一个进程，在进程运行过程中必须至少有一条线程实在运行中。线程本身是不会独立存在的，因为线程是进程中的一个执行路径。</p><p>操作系统在分配资源时是把资源分配给进程的，但是CPU资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU 分配的基本单位。在Java中，当我们启动main函数时其实就启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，也称主线程。</p><blockquote><p>在单核CPU的计算机中，其实并没有真正的并行运算，一般是使用时间片轮转方式让线程轮询占用的，只不过快速的轮转调度带给你的错觉，让你产生了它们真的在同一时刻同时运行。当然如果是多核CPU,那么并行运行还是真实存在的。</p></blockquote><h2 id="2-JAVA中的线程创建和运行"><a href="#2-JAVA中的线程创建和运行" class="headerlink" title="2.JAVA中的线程创建和运行"></a>2.JAVA中的线程创建和运行</h2><p>Java中有三种线程的创建方式，分别为实现Runnable接口的run方法，集成Thread类重写run方法，使用FutureTask方式。</p><h3 id="首先来看看Thread类方式的实现"><a href="#首先来看看Thread类方式的实现" class="headerlink" title="首先来看看Thread类方式的实现"></a>首先来看看Thread类方式的实现</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承Thread,重写run方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="type">MyThread</span> myThread = <span class="keyword">new</span> <span class="type">MyThread</span>();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出MyThread类继承了Thread类，并重写了run()方法。在 main 函数中创建了MyThread的实例并调用了start方式启动了线程。</p><p>使用继承有个不好的地方就是Java是不支持多继承的，所以如果使用了继承方式，那么就不能再继承其他类。还有就是任务与代码没有分离，当多个线程执行一样的任务时就会产生代码冗余。而Runable就没有这个限制。下面我们来看看Runnable接口的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(myThread).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，两个线程公用了一个代码逻辑，并且MyThread可以继承其他类。但是两种方式都有一个缺点，就是任务没有返回值。下面我们可以来看看FutureTask方式。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Callable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Callable</span></span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> call() throws Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建任务</span></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> <span class="type">MyThread</span>();</span><br><span class="line">        FutureTask&lt;<span class="keyword">String</span>&gt; futureTask = <span class="keyword">new</span> <span class="type">FutureTask</span>&lt;&gt;(myThread);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(futureTask).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待任务执行完成,并返回结果</span></span><br><span class="line">            <span class="keyword">String</span> result = futureTask.<span class="keyword">get</span>();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中的MyThread类实现了Callable接口的call()方法。在main函数中创建了一个FutrueTask对象，然后使用FutrueTask对象作为任务创建一个线程并启动。最后通过get()等待任务执行完成拿到结果。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二、【Java并发】线程生命周期以及常用方法详解</title>
      <link href="/thread_two/"/>
      <url>/thread_two/</url>
      
        <content type="html"><![CDATA[<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>每个线程都有自己的生命周期，下面我们就来详细的了解一下。 </p><p><img src="http://file.yuxuan.video/15573707021512.jpg" alt=""></p><p>从上图我们可以看出线程的生命周期大致可以分为五个阶段：</p><ul><li>NEW(新建状态)</li><li>RUNNABLE(就绪状态)</li><li>RUNNING(运行状态)</li><li>BLOCKED(阻塞状态)</li><li>TERMINATED(死亡状态)</li></ul><h3 id="NEW-新建状态"><a href="#NEW-新建状态" class="headerlink" title="NEW(新建状态)"></a>NEW(新建状态)</h3><p>当我们new一个Thread对象时，此时它并不处于运行状态，因为还没有调用start方法启动线程。那么线程的NEW状态，其实只是Thread对象的状态，在没有调用start方法之前，该线程根本不存在，和new一个普通的Java对象没什么区别。NEW状态可以通过start方法进入RUNNABLE状态。</p><h3 id="RUNNABLE-就绪状态"><a href="#RUNNABLE-就绪状态" class="headerlink" title="RUNNABLE(就绪状态)"></a>RUNNABLE(就绪状态)</h3><p>线程对象进入RUNNABLE状态必须调用start方法，此时JVM进程中才会真正的创建一个线程，线程启动后并不会立即得到执行。线程是否运行和进程一样都要听从CPU的调度，为此我们把这个中间状态成为就绪状态，也称为可执行状态(RUNNABLE),也就是说它具备执行的资格，但是并没有真正的执行而是在等待CPU的调度。</p><p>由于存在Running状态，所以不会直接进人BLOCKED状态和TERMINATED状态，即使是在线程的执行逻辑中调用wait、sleep或者其他block的I0操作等，也必须先获得CPU的调度执行权才可以，严格来讲，RUNNABLE的线程只能意外终止或者进人RUNNING状态。</p><h3 id="RUNNING-运行状态"><a href="#RUNNING-运行状态" class="headerlink" title="RUNNING(运行状态)"></a>RUNNING(运行状态)</h3><p>一旦CPU通过时间片轮转或者其他方式选中了线程，那么此时它才能真正的执行自己的逻辑。这里需要注意的一点是一个正在RUNNING状态的线程其实也是RUNNABLE的，但是反过来则不成立。<br>在RUNNING状态中，线程的状态可以发生如下的状态转换：</p><ul><li>直接进人TERMINATED状态，比如调用JDK已经不推荐使用的stop方法或者判断某个逻辑标识。</li><li>进人BLOCKED状态，比如调用了sleep,或者wait方法而加入了waitSet 中。</li><li>进行某个阻塞的I0操作，比如因网络数据的读写而进入了BLOCKED状态。</li><li>获取某个锁资源，从而加入到该锁的阻塞队列中而进人了BLOCKED状态。</li><li>由于CPU的调度器轮询使该线程放弃执行，进人RUNNABLE状态。</li><li>线程主动调用yield方法，放弃CPU执行权，进入RUNNABLE状态。</li></ul><h3 id="BLOCKED-阻塞状态"><a href="#BLOCKED-阻塞状态" class="headerlink" title="BLOCKED(阻塞状态)"></a>BLOCKED(阻塞状态)</h3><p>上面列举了线程进入BLOCKED状态的原因，下面我们在列举线程在BLOCKED状态中可能切换的状态：</p><ul><li>直接进人TERMINATED状态，比如调用JDK已经不推荐使用的stop方法或者意外死亡(JVM Crash)。</li><li>线程阻塞的操作结束，比如读取了想要的数据字节进人到RUNNABLE状态。</li><li>线程完成了指定时间的休眠，进人到了RUNNABLE状态。</li><li>Wait中的线程被其他线程notify/notifyall唤醒，进人RUNNABLE状态。</li><li>线程获取到了某个锁资源，进人RUNNABLE状态。</li><li>线程在阻塞过程中被打断，比如其他线程调用了interrupt方法，进人RUNNABLE状态。</li></ul><h3 id="TERMINATED-死亡状态"><a href="#TERMINATED-死亡状态" class="headerlink" title="TERMINATED(死亡状态)"></a>TERMINATED(死亡状态)</h3><p>TERMINATED状态是线程最终状态，在该状态的线程不会再切换到其它任何状态，意味着线程的整个生命周期都结束了。</p><h2 id="Thread-API详解"><a href="#Thread-API详解" class="headerlink" title="Thread API详解"></a>Thread API详解</h2><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><blockquote><p>sleep是一个静态方法，其有两个重载方法，其中一个需要传入毫秒，另外一个既需要毫秒数，还需要纳秒数<br>public static native void sleep(long millis) throws InterruptedException;<br>public static void sleep(long millis, int nanos) throws InterruptedException</p></blockquote><p>sleep方法会使当前线程休眠指定的毫秒数，暂停执行，其中有个要注意的点，sleep并不会释放锁资源。</p><p>JDK1.5以后，JDK引入了一个枚举TimeUnit，其对sleep做了很好的封装。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//休眠一天</span></span><br><span class="line">TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一小时</span></span><br><span class="line">TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一分钟</span></span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一秒</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一毫秒</span></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>yield也是一个静态方法，调用此方法会提醒调度器我愿意放弃当前的cpu资源，如果CPU资源不紧张的话，调度器可能会忽略这个提醒。操作系统是为每个线程分配一个时间片来占有CPU的，正常情况下当一个线程把分配给自己的时间片使用完后，线程调度器才会进行下一轮的线程调度，而当一个线程调用了Thread类的静态方法yield时，是在告诉线程调度器自己占有的时间片中还没有使用完的部分自己不想使用了，这暗示线程调度器现在就可以进行下一轮的线程调度。</p><blockquote><p>sleep 与 yield 方法的区别在于，当线程调用sleep方法时调用线程会被阻塞挂 起指定的时间，在这期间线程调度器不会去调度该线程。而调用yield 方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到当前线程执行 。</p></blockquote><h3 id="setPriority-amp-getPriority-线程优先级"><a href="#setPriority-amp-getPriority-线程优先级" class="headerlink" title="setPriority()&amp;getPriority() 线程优先级"></a>setPriority()&amp;getPriority() 线程优先级</h3><p>在操作系统中，进程有优先级之分，线程同样也有优先级，理论上优先级高的线程有被CPU优先调度的机会，但真实情况往往并不会如你所愿，因为设置线程优先级也是一个hint(暗示)操作。</p><ul><li>对于root用户，它会hint操作系统你想要设置的优先级别，否则它会被忽略。</li><li>在CPU比较忙的情况下，设置优先级可能会获取更多的CPU调度机会，但是闲时优先级的高低一般不会有任何作用。</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单来看看设置优先级方法的源码</span></span><br><span class="line"><span class="keyword">public</span> final void setPriority(int <span class="keyword">new</span><span class="type">Priority</span>) &#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Priority</span> &gt; MAX_PRIORITY || <span class="keyword">new</span><span class="type">Priority</span> &lt; MIN_PRIORITY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((g = getThreadGroup()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Priority</span> &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                <span class="keyword">new</span><span class="type">Priority</span> = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = <span class="keyword">new</span><span class="type">Priority</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析如上代码，可以看出线程的优先级必须是1~10，如果指定的线程优先级大于线程所在的group的优先级，那么会忽略指定的优先级从而获取group的最大优先级。线程默认的优先级和创建它的那个线程保持一致，一般情况下都是5.</p><h3 id="获取线程ID-getId"><a href="#获取线程ID-getId" class="headerlink" title="获取线程ID getId()"></a>获取线程ID getId()</h3><p>getId()获取线程的唯一ID,线程的ID在整个JVM进程中都是唯一的。</p><h3 id="线程-interrupt相关方法"><a href="#线程-interrupt相关方法" class="headerlink" title="线程 interrupt相关方法"></a>线程 interrupt相关方法</h3><ul><li><p>interrupt()方法<br>在线程内部存在着名为interrupt flag的标识，如果一个线程调用了interrupt方法，flag会被设置，但是如果当前线程正处于阻塞状态时，调用interrupt，线程将会中断阻塞，并且会抛出InterruptedException异常，这个异常就像是一个signal(信号)一样通知当前线程被打断了，并且flag会被清除。</p></li><li><p>isInterrupted()方法<br>此方法是Thread类的实例方法，主要判断当前线程是否被中断。</p></li><li><p>interrupted()方法<br>此方法是Thread中的一个静态方法，也是主要用于判断当前线程是否被中断，但是它和isInterrupted()方法有个区别就是该方法会直接清除掉该线程的interrupt标识</p></li></ul><h3 id="线程join方法"><a href="#线程join方法" class="headerlink" title="线程join方法"></a>线程join方法</h3><p>join方法会使当前线程永远的等待下去，直到期间被另外的线程中断，或者join的线程执行结束，也可以使用另外两个重载方法，指定等待毫秒数，在指定的时间到达之后，当前线程也回退出阻塞。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">join</span><span class="params">()</span></span> 一直等待</span><br><span class="line"><span class="function"><span class="title">join</span><span class="params">(long millis)</span></span> 等待指定毫秒数</span><br><span class="line"><span class="function"><span class="title">join</span><span class="params">(long millis, int nanos)</span></span> 等待指定毫秒数</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式(四) 工厂方法模式</title>
      <link href="/pattern_factory_method/"/>
      <url>/pattern_factory_method/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>工厂方法模式又称工厂模式,也叫多态工厂模式,属于类创建型模式<br>工厂方法模式实质就是: 把创建对象的过程抽象出来不实现,让其子类或实现类来决定实例化那个类.</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="我们先简单的来看看工厂模式的组成"><a href="#我们先简单的来看看工厂模式的组成" class="headerlink" title="我们先简单的来看看工厂模式的组成:"></a>我们先简单的来看看工厂模式的组成:</h3><blockquote><ol><li>抽象工厂(abstract factory): 抽象对象.</li><li>具体工厂实现(real factory): 实际创建对象的工厂,负责创建一个或多个对象。</li><li>抽象产品(abstract product): 工厂角色生产的所有对象都需要依赖此抽象。一般通过接口或者抽象类来实现.</li><li>具体产品实现(real product): 具体的产品实现,依赖抽象角色.由工厂角色来创建</li></ol></blockquote><h3 id="抽象Car"><a href="#抽象Car" class="headerlink" title="抽象Car"></a>抽象Car</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* car抽象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 车俩启动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体Car实现"><a href="#具体Car实现" class="headerlink" title="具体Car实现"></a>具体Car实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 红色车辆实现类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"BMW run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"QQ run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 抽象工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体工厂实现"><a href="#具体工厂实现" class="headerlink" title="具体工厂实现"></a>具体工厂实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 宝马用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWCarFactory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BMWCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 宝马用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQCarFactory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> QQCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式的优缺点"><a href="#工厂方法模式的优缺点" class="headerlink" title="工厂方法模式的优缺点"></a>工厂方法模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>在工厂方法模式中，使用方只需要知道所要对象的具体工厂，无须关心具体的创建过程，甚至不需要具体类的类名</li><li>在系统增加新的对象时，我们只需要添加一个具体实现类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>每次增加一个对象时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>工厂方法模式完全符合“开闭原则”。</li><li>工厂方法模式使用继承，将对象的创建交给子类，通过子类实现工厂方法来创建对象。</li><li>工厂方法让子类决定要实例化的类是哪一个。</li><li>在工厂方法模式中，创建者通常会包含依赖于抽象产品的代码，而这些抽象产品是、由子类创建的，创建者不需要真的知道在制作哪种具体产品。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式(三) 简单工厂模式</title>
      <link href="/pattern_simple_factory/"/>
      <url>/pattern_simple_factory/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>简单工厂模式又称之为静态工厂方法(Static Factory Method), 属于创建型模式。简单工厂模式是根据传递的参数不同, 返回不同实现类的实例对象.（这些类都依赖一个父类或接口） </p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="我们先简单的来看看简单工厂模式的组成"><a href="#我们先简单的来看看简单工厂模式的组成" class="headerlink" title="我们先简单的来看看简单工厂模式的组成:"></a>我们先简单的来看看简单工厂模式的组成:</h3><blockquote><ol><li>工厂类角色(Factory): 工厂类是工厂模式的最重要的组成部分. 向外提供一个创建方法,该方法会根据传递的参数来返回对应的实现类的实例对象。</li><li>抽象产品角色(abstract product): 工厂角色生产的所有对象都需要依赖此抽象。一般通过接口或者抽象类来实现.</li><li>具体产品实现角色(real product): 具体的产品实现,依赖抽象角色.由工厂角色来创建</li></ol></blockquote><h3 id="工厂类"><a href="#工厂类" class="headerlink" title="工厂类"></a>工厂类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 专门用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">    car = <span class="keyword">new</span> RedCar();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"black"</span>:</span><br><span class="line">        car = <span class="keyword">new</span> BlackCar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象Car类"><a href="#抽象Car类" class="headerlink" title="抽象Car类"></a>抽象Car类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 专门用来创建车辆的工厂类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">        car = <span class="keyword">new</span> RedCar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"black"</span>:</span><br><span class="line">        car = <span class="keyword">new</span> BlackCar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Car实现类"><a href="#Car实现类" class="headerlink" title="Car实现类"></a>Car实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 红色车辆实现类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sprayPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"red car"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 黑色车辆实现类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sprayPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"black car"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式的优缺点"><a href="#简单工厂模式的优缺点" class="headerlink" title="简单工厂模式的优缺点"></a>简单工厂模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>明确了各自的职责和权利，有利于整个软件体系结构的优化</li><li>使用方无须知道创建类的过程,只需要提供对应的参数即可.</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于工厂集中了所有对象的创建逻辑,一旦工厂出了问题,就会导致整个系统受到影响.</li><li>系统扩展受限,一旦添加新的对象就需要修改工厂逻辑,在对象类型过多时,势必会导致工厂逻辑过于复杂和臃肿,不利于系统的扩展和维护</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>简单工厂的好处就在于你需要什么,只需要传递一个规则内的参数,就可以获取到所需要的对象.</li><li>简单工厂的核心理念就是把对象的创建和对象的使用分离开来.为此当对象类型过多时势必会导致创建环节的臃肿</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式(二) 单例模式</title>
      <link href="/pattern_singleton/"/>
      <url>/pattern_singleton/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>程序在运行时，通常都会生成很多实例。例如，表示字符串的 String 类的实例与字符串是一一对应的关系，所以当有 1000 个字符串的时候，会生成 1000 个实例。</p><p>但是，当我们想在程序中表示某个东西只会存在一个时，就会有“只能创建-一个实例”的需求。典型的例子有表示程序所运行于的那台计算机的类、表示软件系统相关设置的类，以及表示视窗系统（window system）的类。<br>当然，只要我们在编写程序时多加注意，确保只调用一次 new MyClass（），就可以达到只生成一个实例的目的。但是，如果我们不想“必须多加注意才能确保生成一个实例”，而是要达到如下目的时，应当怎么做呢？</p><ul><li>想确保任何情况下都绝对只有 1 个实例</li><li>想在程序上表现出“只存在一个实例”</li></ul><p>像这样的确保只生成-一个实例的模式被称作 Singleton 模式。Singleton 是指只含有一个元素的集合。因为本模式只能生成一个实例，因此以 Singleton 命名。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>众所周知,一个类的实例对象产生是通过构造函数来完成的. 因此如果不想让外界随意新建对象的话我们可以通过把构造函数私有化. 当然为了让类保证可用, 就需要自己提供一个可以返回自己的实例对象的通道, 一般我们使用静态方法来暴露实例对象.</p><p>实现单例模式的方式有很多种,不同的方式都有不同的优缺点,下面我们就来一一讲解:</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式--饿汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部实例化一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry hungry = <span class="keyword">new</span> Hungry();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的单例实现,一般称之为饿汉式.为何叫饿汉式,这个比喻很形象,可以看出上面的对象其实在类第一次被加载后就被创建了.这样有个好处就是避免了线程安全问题.但是这样另外一个问题,因为对象实在类被第一次加载后就被创建了,可能会造成不必要的消耗,因为有可能这个实力不会被用到.基于这个原因从而引出另一个实现方式: <code>懒汉式</code>,下面我们来看看:</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式--懒汉式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yuxuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//内部实例化一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对外提供获取对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对象被使用时才初始化</span></span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">             lazy = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现方式就叫做懒汉式。懒汉，顾名思义就是不会提前把实例对象创建出来，而是将创建的动作放在了第一次使用的时候.</p><p>但是,仔细一看就会发现上面的实现方式存在一个问题，那就是线程安全问题。在多线程情况下，有可能两个线程同时需要使用此对象,从而存在同时进入if语句中，最后在两个线程执行完方法后创建了两个不同的对象. 针对这个问题, 我们尝试做出如下修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部实例化一个对象</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 私有构造</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//对外提供获取对象方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (Lazy.class) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      lazy = <span class="keyword">new</span> Lazy();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> lazy;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过修改之后,我们发现可以通过加锁的方式来解决了线程同步的问题.</p><p>但是熟悉Java内存模式的同学会发现还是会存在潜在的危险.</p><blockquote><p>在J2SE1.5版本之前使用双重锁检查时会有潜在的危险,有时会正常工作,有时候会因为线程的调度和其他并发系统活动，不正确的实现双重检查锁导致的异常结果可能会间歇性出现。重现异常是十分困难的。此问题在J2SE 5.0中被处理了.我们可以通过volatile关键字来处理</p></blockquote><p>我们只需要在我们声明的对象上加上<code>volatile</code>修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lazy lazy;</span><br></pre></td></tr></table></figure><p>好了,到此关于线程安全的问题我们解决了.</p><p>现在我们再来考虑一个问题, 做过java的同学,想必对反射和序列化不陌生.为什么在这里提这两个呢? 因为这两个可能会破坏我们的单例.(具体什么原因,后面我会有详细的文章介绍).针对这个问题我们可以做出如下修改就可以解决:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们只需要在单例类里定义此方法就能解决</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lazy;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
